# This file is used to create SWIG based JNI interfaces to C++ code.  You use
# it by defining some CMake variables and then include(cmake_swig_jni).  You
# would make a CMakeLists.txt file that looks like the following:
#
#   cmake_minimum_required (VERSION 2.8.11)
#   project (example)
#   set(java_package_name "org.mycompany")
#   set(swig_interface_file example.i)
#   set(source_files
#       your_cpp_source.cpp
#       more_cpp_source.cpp
#   )
#
#   ### We might need to link our code to some other C++ library like dlib.  You
#   ### can do that by setting additional_link_libraries.  Here is an example of
#   ### linking to dlib:
#   set(CMAKE_POSITION_INDEPENDENT_CODE True)
#   include(../projects/tools/dclib/dlib/cmake)
#   set(additional_link_libraries dlib)
#
#   include(cmake_swig_jni)







################################################################################
################################################################################
#                             IMPLEMENTATION DETAILS
################################################################################
################################################################################

cmake_minimum_required (VERSION 2.8.11)

# This block of code tries to figure out what the JAVA_HOME environment
# variable should be by looking at the folder that contains the java
# executable.
if (NOT DEFINED ENV{JAVA_HOME})
   message(STATUS "JAVA_HOME environment variable not set, trying to guess it...")
   find_program(JAVA_EXECUTABLE java)
   # Resolve symbolic links, hopefully this will give us a path in the proper
   # java home directory.
   get_filename_component(JAVA_EXECUTABLE ${JAVA_EXECUTABLE} REALPATH)
   # Pick out the parent directories
   get_filename_component(JAVA_PATH1 ${JAVA_EXECUTABLE} PATH)
   get_filename_component(JAVA_PATH2 ${JAVA_PATH1} PATH)
   # and search them for include/jni.h.  If we find that then we probably have
   # a good java home candidate.
   find_path(AUTO_JAVA_HOME include/jni.h
      PATHS
      ${JAVA_PATH1}
      ${JAVA_PATH2}
      "C:/Program Files/Java/jdk*"
      )

   if (AUTO_JAVA_HOME)
      set(ENV{JAVA_HOME} ${AUTO_JAVA_HOME})
      message(STATUS "Using JAVA_HOME OF " ${AUTO_JAVA_HOME})
   else()
      message(FATAL_ERROR "Couldn't find a folder for JAVA_HOME.  You must set the JAVA_HOME environment variable before running CMake.")
   endif()
endif()

set(CMAKE_LIBRARY_OUTPUT_DIRECTORY "${CMAKE_CURRENT_BINARY_DIR}/lib")
set(CMAKE_LIBRARY_OUTPUT_DIRECTORY_RELEASE "${CMAKE_CURRENT_BINARY_DIR}/lib")

find_package(SWIG REQUIRED)
find_package(Java REQUIRED)
find_package(JNI REQUIRED)
include(UseSWIG)

# SWIG doesn't work if optimizations are enabled and strict aliasing is not
# turned off.  This is a little wonky but it's how SWIG is.
if (CMAKE_COMPILER_IS_GNUCXX)
    add_definitions(-fno-strict-aliasing)
endif()


string(REGEX REPLACE "\\." "/" package_path ${java_package_name})
string(REGEX REPLACE "\\..*" "" package_root_name ${java_package_name})

set(CMAKE_SWIG_FLAGS -package ${java_package_name})
set(CMAKE_SWIG_OUTDIR ${CMAKE_CURRENT_BINARY_DIR}/lib/java_src/${package_path})

set_source_files_properties(${swig_interface_file} PROPERTIES CPLUSPLUS ON)
swig_add_module(${PROJECT_NAME} java ${swig_interface_file} ${source_files})

include_directories(${JNI_INCLUDE_DIRS})
swig_link_libraries(${PROJECT_NAME}  ${additional_link_libraries})

# Things to delete when "make clean" is run.
set(clean_files
    ${CMAKE_CURRENT_BINARY_DIR}/intermediate_files_compiled
    ${CMAKE_CURRENT_BINARY_DIR}/lib/java_src 
    )
set_directory_properties(PROPERTIES ADDITIONAL_MAKE_CLEAN_FILES "${clean_files}")

# Compile the java files into a jar file and stick it in the lib folder.
add_custom_command(TARGET ${PROJECT_NAME} 
   POST_BUILD
   COMMAND cmake -E echo "compiling Java files..."
   COMMAND cmake -E make_directory "${CMAKE_CURRENT_BINARY_DIR}/intermediate_files_compiled"
   COMMAND ${Java_JAVAC_EXECUTABLE} ${CMAKE_SWIG_OUTDIR}/*.java -d "${CMAKE_CURRENT_BINARY_DIR}/intermediate_files_compiled"
   COMMAND cmake -E echo "Making jar file..."
   COMMAND ${Java_JAR_EXECUTABLE} cvf "${CMAKE_CURRENT_BINARY_DIR}/lib/${PROJECT_NAME}.jar" -C "${CMAKE_CURRENT_BINARY_DIR}/intermediate_files_compiled" ${package_root_name}
   )

# Copy any system libraries to the output folder.  This really only matters on
# windows where it's good to have the visual studio runtime show up in the lib
# folder so that you don't forget to include it in your binary distribution.
INCLUDE(InstallRequiredSystemLibraries)
foreach (file_i ${CMAKE_INSTALL_SYSTEM_RUNTIME_LIBS})
   add_custom_command(TARGET ${PROJECT_NAME}
      POST_BUILD
      COMMAND cmake -E copy ${file_i} "${CMAKE_CURRENT_BINARY_DIR}/lib/"
      )
endforeach()


#if the including cmake script set the install_target_output_folder variable
#then make it so we install the compiled library and jar into that folder
if (install_target_output_folder)
    # Determine the path to our CMakeLists.txt file.
    string(REGEX REPLACE "CMakeLists.txt$" "" base_path ${CMAKE_PARENT_LIST_FILE})
    # Tell cmake to copy the needed visual studio runtime dll files into the output folder if we are using visual studio.
    set(CMAKE_INSTALL_SYSTEM_RUNTIME_DESTINATION ${base_path}/${install_target_output_folder})
    INCLUDE(InstallRequiredSystemLibraries)
    install(TARGETS ${PROJECT_NAME} DESTINATION ${base_path}/${install_target_output_folder})
    install(FILES ${CMAKE_CURRENT_BINARY_DIR}/lib/${PROJECT_NAME}.jar DESTINATION ${base_path}/${install_target_output_folder})
endif()
